@page "/feedback/list"
@rendermode InteractiveWebAssembly

@inject FeedbackInMemoryService _feedbackInMemory
@inject NavigationManager NavManager

<h3>Feedback Submissions</h3>

<button class="btn btn-primary" @onclick="NavigateToAddFeedback">Add New Feedback</button>
@if (feedbackListItems.Count == 0)
{
    <p>No feedback submissions found.</p>
}
else
{
    <hr/>
    <ul class="list-group">
        @foreach (var feedback in feedbackListItems)
        {
            <li class="list-group-item" @key="feedback.ToString()">
                <strong>Name:</strong> @feedback.Name <br />
                <strong>Email:</strong> @feedback.Email <br />
                <strong>Comment:</strong> @feedback.Comment 

                <span class="float-end">
                    <button class="btn btn-primary" @onclick="() => EditFeedback(feedback)">Edit</button>
                    <br />
                    <button class="btn btn-danger" @onclick="() => RemoveFeedback(feedback)">Remove</button>
                    <br />
                    <strong> @DateTime.Now.ToString("T")</strong>
                    <strong> @feedback.ToString()</strong>
                </span>
            </li>
        }
    </ul>
}
<hr />
<button class="btn btn-danger" @onclick="ClearFeedbacks">Clear Feedbacks</button>

@if (isLoaded)
{
    <p class="text-success">Feedback loaded successfully!</p>
}
else
{
    <p class="text-warning">Loading feedback...</p>
}

@code {
    private List<Feedback> feedbackListItems = [];
    private bool isLoaded = false;
    private int feedbackCount = 0;

    protected override void OnInitialized()
    {
        isLoaded = false;
        // Service is being called twice due to the interactive mode
        // Some how it keep different instances for the _feedbackInMemory service
        if(this.RendererInfo.IsInteractive)
        {   
            _feedbackInMemory.SubmitFeedback(new Feedback
            {
                Name = "John Doe",
                Email = "j@test.com",
                Comment = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")
            });

            feedbackListItems = _feedbackInMemory.GetAllFeedbacks();
            isLoaded = true;
        }
    }

    private void NavigateToAddFeedback()
    {
        NavManager.NavigateTo("/feedback/add", false);
    }

    private void EditFeedback(Feedback feedback)
    {
        NavManager.NavigateTo($"/feedback/edit/{feedback.Id}", false);
    }
    private void RemoveFeedback(Feedback feedback)
    {
        _feedbackInMemory.RemoveFeedback(feedback);
        //feedbackListItems = _feedbackInMemory.GetAllFeedbacks();
        feedbackListItems.Remove(feedback);
        StateHasChanged();
    }

    private void ClearFeedbacks()
    {
        _feedbackInMemory.ClearFeedback();
        feedbackListItems.Clear();
    }
}